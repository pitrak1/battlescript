class list_iterator:
    def __init__(self, lst):
        self.__list = lst
        self.__index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.__index >= len(self.__list):
            raise StopIteration()
        value = self.__list[self.__index]
        self.__index = self.__index + 1
        return value


class list:
    __btl_value = __btl_sequence__()

    def __init__(self, value):
        if isinstance(value, list):
            self.__btl_value = value.__btl_value
        else:
            self.__btl_value = value

    def __getitem__(self, key):
        result = self.__btl_value[key]
        if isinstance(result, __btl_sequence__):
            return list(result)
        else:
            return result

    def __setitem__(self, key, value):
        self.__btl_value[key] = value

    def __delitem__(self, key):
        del self.__btl_value[key]

    def __add__(self, other):
        if isinstance(other, list):
            return list(self.__btl_value + other.__btl_value)
        return NotImplemented

    def __iadd__(self, other):
        if isinstance(other, list):
            self.__btl_value = self.__btl_value + other.__btl_value
            return self
        return NotImplemented

    def __mul__(self, other):
        if isinstance(other, int):
            return list(self.__btl_value * other.__btl_value)
        return NotImplemented

    def __imul__(self, other):
        if isinstance(other, int):
            self.__btl_value = self.__btl_value * other.__btl_value
            return self
        return NotImplemented

    def __bool__(self):
        return 0 < len(self.__btl_value)

    def __eq__(self, other):
        return bool(self.__btl_value == other.__btl_value)

    def __ne__(self, other):
        return bool(self.__btl_value != other.__btl_value)
    
    def __len__(self):
        return len(self.__btl_value)

    def __iter__(self):
        return list_iterator(self)

    def append(self, value):
        length = len(self)
        self[length:] = [value]
    
    def extend(self, iterable):
        self[len(self):] = iterable

    def insert(self, index, value):
        self[index:index] = [value]

    def index(self, value):
        for i in range(len(self)):
            if self[i] == value:
                return i
        raise ValueError("value not in list")

    def remove(self, value):
        i = self.index(value)
        self[i:i + 1] = []

    def pop(self, index=-1):
        if index < 0:
            index = len(self) + index
        value = self[index]
        self[index:index + 1] = []
        return value

    def clear(self):
        self[0:len(self)] = []

    def count(self, value):
        c = 0
        for item in self:
            if item == value:
                c = c + 1
        return c

    def reverse(self):
        left = 0
        right = len(self) - 1
        while left < right:
            # swap
            temp = self[left]
            self[left] = self[right]
            self[right] = temp

            # move indices toward middle
            left = left + 1
            right = right - 1

    def sort(self, key=None):
        for i in range(1, len(self)):
            # get current value to insert
            current = self[i]
            if key:
                current_key = key(current)
            else:
                current_key = current

            # shift larger values to the right
            j = i - 1
            while j >= 0:
                if key:
                    compare_key = key(self[j])
                else:
                    compare_key = self[j]
                if compare_key > current_key:
                    self[j + 1] = self[j]
                    j = j - 1
                else:
                    break
            self[j + 1] = current
